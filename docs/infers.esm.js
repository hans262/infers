var u=class{constructor(t){if(!t[0])throw new Error("Matrix at least one row");if(t.find((r,i)=>t[i-1]&&r.length!==t[i-1].length))throw new Error("Matrix column inconsistent");if(!t[0].length)throw new Error("Matrix has at least one element from row");this.shape=[t.length,t[0].length],this.self=t}slice(t,e){return new u(this.self.slice(t,e))}argMax(t){let e=this.getRow(t),r=e[0],i=0;for(let n=0;n<e.length;n++)e[n]>r&&(r=e[n],i=n);return i}connect(t){if(this.shape[1]!==t.shape[1])throw new Error("Matrix column inconsistent");let e=this.dataSync().concat(t.dataSync());return new u(e)}zeroed(){return this.atomicOperation(t=>0)}clone(){return new u(this.dataSync())}getMeanOfRow(t){let e=this.getRow(t);return e.reduce((r,i)=>r+i)/e.length}sum(){let t=0;for(let e=0;e<this.shape[0];e++)for(let r=0;r<this.shape[1];r++)t+=this.get(e,r);return t}columnSum(){let t=[];for(let e=0;e<this.shape[1];e++)t.push(this.getCol(e).reduce((r,i)=>r+i));return new u([t])}dataSync(){let t=[];for(let e=0;e<this.shape[0];e++){let r=[];for(let i=0;i<this.shape[1];i++)r.push(this.get(e,i));t.push(r)}return t}equalsShape(t){return this.shape[0]===t.shape[0]&&this.shape[1]===t.shape[1]}equals(t){if(!this.equalsShape(t))return!1;for(let e=0;e<this.shape[0];e++)for(let r=0;r<this.shape[1];r++)if(this.get(e,r)!==t.get(e,r))return!1;return!0}static generateIdentity(t){let e=this.generate(t,t,0),r=0;for(let i=0;i<e.shape[0];i++)e.update(i,r++,1);return e}static generate(t,e,r={range:[-.5,.5]}){let i=[];for(let n=0;n<t;n++){let s=[];for(let a=0;a<e;a++){let o=0;if(typeof r=="number")o=r;else{let[h,l]=[Math.min(...r.range),Math.max(...r.range)],c=h<0||l<0?-1:0;o=Math.random()*(l-h)+h+c,r.integer&&(o=~~o)}s.push(o)}i.push(s)}return new u(i)}update(t,e,r,i){switch(i){case"+=":this.self[t][e]+=r;break;case"-=":this.self[t][e]-=r;break;case"*=":this.self[t][e]*=r;break;case"/=":this.self[t][e]/=r;break;default:this.self[t][e]=r}}expand(t,e){let r=[];for(let i=0;i<this.shape[0];i++){let n=e==="L"?[t,...this.getRow(i)]:e==="R"?[...this.getRow(i),t]:[...this.getRow(i)];r.push(n)}return e==="T"?r.unshift(new Array(r[0].length).fill(t)):e==="B"&&r.push(new Array(r[0].length).fill(t)),new u(r)}get(t,e){return this.self[t][e]}getRow(t){return[...this.self[t]]}getCol(t){let e=[];for(let r=0;r<this.shape[0];r++)for(let i=0;i<this.shape[1];i++)i===t&&e.push(this.get(r,i));return e}adjugate(){if(this.shape[0]!==this.shape[1])throw new Error("\u53EA\u6709\u65B9\u9635\u624D\u80FD\u6C42\u4F34\u968F\u77E9\u9635");return this.shape[0]===1?new u([[1]]):this.shape[0]===2?new u([[this.get(1,1),this.get(0,1)*-1],[this.get(1,0)*-1,this.get(0,0)]]):this.clone().atomicOperation((t,e,r)=>this.cominor(e,r).det()*(-1)**(e+r+2)).T}inverse(){if(this.shape[0]!==this.shape[1])throw new Error("\u53EA\u6709\u65B9\u9635\u624D\u80FD\u6C42\u9006");let t=this.det();if(t===0)throw new Error("\u8BE5\u77E9\u9635\u4E0D\u53EF\u9006");return this.adjugate().atomicOperation(r=>r/t)}det(){if(this.shape[0]!==this.shape[1])throw new Error("\u53EA\u6709\u65B9\u9635\u624D\u80FD\u8BA1\u7B97\u884C\u5217\u5F0F");if(this.shape[0]===1)throw new Error("\u77E9\u9635\u884C\u5FC5\u987B\u5927\u4E8E1");if(this.shape[0]===2&&this.shape[1]===2)return this.get(0,0)*this.get(1,1)-this.get(0,1)*this.get(1,0);{let t=0;for(let e=0;e<this.shape[1];e++)this.get(0,e)!==0&&(t+=this.get(0,e)*(-1)**(e+2)*this.cominor(0,e).det());return t}}cominor(t,e){if(this.shape[0]<2||this.shape[1]<2)throw new Error("\u6C42\u4F59\u5B50\u5F0F\u884C\u548C\u5217\u5FC5\u987B\u5927\u4E8E2\u624D\u6709\u610F\u4E49");let r=this.dataSync().map(i=>(i=i.filter((n,s)=>s!==e),i)).filter((i,n)=>n!==t);return new u(r)}atomicOperation(t){let e=[];for(let r=0;r<this.shape[0];r++){let i=[];for(let n=0;n<this.shape[1];n++)i.push(t(this.get(r,n),r,n));e.push(i)}return new u(e)}coLocationOperation(t,e){if(!this.equalsShape(t))throw new Error("\u5FC5\u987B\u6EE1\u8DB3\u4E24\u4E2A\u77E9\u9635\u662F\u540C\u5F62\u77E9\u9635");let r=[];for(let i=0;i<this.shape[0];i++){let n=[];for(let s=0;s<this.shape[1];s++){let[a,o]=[this.get(i,s),t.get(i,s)],h=e==="add"?a+o:e==="sub"?a-o:e==="mul"?a*o:e==="exp"?a/o:a;n.push(h)}r.push(n)}return new u(r)}subtraction(t){return this.coLocationOperation(t,"sub")}addition(t){return this.coLocationOperation(t,"add")}multiply(t){if(typeof t=="number")return this.atomicOperation(s=>s*t);if(this.shape[1]!==t.shape[0])throw new Error("\u5F53\u77E9\u9635A\u7684\u5217\u6570\u7B49\u4E8E\u77E9\u9635B\u7684\u884C\u6570\uFF0CA\u4E0EB\u624D\u53EF\u4EE5\u76F8\u4E58");let e=this.shape[0],r=t.shape[1],i=t.T,n=[];for(let s=0;s<e;s++){let a=[];for(let o=0;o<r;o++){let h=this.getRow(s).reduce((l,c,p)=>l+c*i.get(o,p),0);a.push(h)}n.push(a)}return new u(n)}get T(){let t=[];for(let e=0;e<this.shape[1];e++){let r=[];for(let i=0;i<this.shape[0];i++)r.push(this.get(i,e));t.push(r)}return new u(t)}normalization(t="average"){let e=this.T,r=[];for(let i=0;i<e.shape[0];i++){let n=Math.max(...e.getRow(i)),s=Math.min(...e.getRow(i)),a=n-s,o=s+a/2,h=t==="average"?o:s;r.push([h,a]);for(let l=0;l<e.shape[1];l++){let c=a===0?0:(e.get(i,l)-h)/a;e.update(i,l,c)}}return[e.T,new u(r).T]}print(){console.log(`Matrix ${this.shape[0]}x${this.shape[1]} [`);for(let t=0;t<this.shape[0];t++){let e=" ";for(let r=0;r<this.shape[1];r++)e+=this.get(t,r)+", ";console.log(e)}console.log("]")}};var x=class{constructor(t,e){this.X=t;this.Y=e}contrast(t){return this.X===t.X&&this.Y===t.Y}},E=class{constructor(t,e){if(this.start=new x(t[0],t[1]),this.end=new x(e[0],e[1]),this.start.contrast(this.end))throw new Error("\u4E24\u4E2A\u70B9\u4E0D\u80FD\u76F8\u540C")}minXY(){let t=Math.min(this.start.X,this.end.X),e=Math.min(this.start.Y,this.end.Y);return new x(t,e)}maxXY(){let t=Math.max(this.start.X,this.end.X),e=Math.max(this.start.Y,this.end.Y);return new x(t,e)}testPointIn(t){if(t.contrast(this.start)||t.contrast(this.end))return!0;let e=t.X-this.start.X==0?Infinity:(t.Y-this.start.Y)/(t.X-this.start.X),r=t.X-this.end.X==0?Infinity:(t.Y-this.end.Y)/(t.X-this.end.X);return e===r}testPointInside(t){if(this.testPointIn(t)){let e=this.minXY(),r=this.maxXY();return t.X>=e.X&&t.X<=r.X&&t.Y>=e.Y&&t.Y<=r.Y}return!1}},P=class{constructor(t){this.points=[];for(let a=0;a<t.length;a++)this.points.push(new x(t[a][0],t[a][1]));if(this.points.length<3)throw new Error("\u81F3\u5C11\u4E09\u4E2A\u70B9");let e=this.points.map(a=>a.X.toString()+a.Y.toString()).sort();if(e.find((a,o)=>a===e[o+1]))throw new Error("\u4E0D\u80FD\u6709\u76F8\u540C\u7684\u70B9");let i=this.points[0],s=this.points.slice(1).map(a=>a.X===i.X?Infinity:(a.Y-i.Y)/(a.X-i.X));if(new Set(s).size===1)throw new Error("\u6240\u6709\u70B9\u4E0D\u80FD\u5728\u4E00\u6761\u7EBF\u4E0A")}testPointInsidePolygon(t){let e=this.points;var r=0,i=e.length;if(i<3)return 0;for(var n=e[0],s=1;s<=i;++s){var a=s===i?e[0]:e[s];if(a.Y===t.Y&&(a.X===t.X||n.Y===t.Y&&a.X>t.X==n.X<t.X))return-1;if(n.Y<t.Y!=a.Y<t.Y){if(n.X>=t.X)if(a.X>t.X)r=1-r;else{var o=(n.X-t.X)*(a.Y-t.Y)-(a.X-t.X)*(n.Y-t.Y);if(o===0)return-1;o>0==a.Y>n.Y&&(r=1-r)}else if(a.X>t.X){var o=(n.X-t.X)*(a.Y-t.Y)-(a.X-t.X)*(n.Y-t.Y);if(o===0)return-1;o>0==a.Y>n.Y&&(r=1-r)}}n=a}return r}};function F(m,t){let e=10**t;return~~(m*e)/e}function R(m,t){let e=m.dataSync(),r=t.dataSync();for(let i=1;i<t.shape[0];i++){let n=Math.floor(Math.random()*(i+1));[e[i],e[n]]=[e[n],e[i]],[r[i],r[n]]=[r[n],r[i]]}return{xs:new u(e),ys:new u(r)}}function O(m,t,e){switch(e){case"Sigmoid":return 1/(1+Math.exp(-m));case"Relu":return m>=0?m:0;case"Tanh":return Math.tanh(m);case"Softmax":let r=Math.max(...t);return Math.exp(m-r)/t.reduce((i,n)=>i+Math.exp(n-r),0);default:return m}}function y(m,t){switch(t){case"Sigmoid":return m*(1-m);case"Relu":return m>=0?1:0;case"Tanh":return 1-Math.tanh(m)**2;case"Softmax":default:return 1}}function A(m){let t=u.generate(m.width,m.height,0);for(let e=0;e<m.width;e++)for(let r=0;r<m.height;r++){let i=e+r*4,n=m.data[i],s=m.data[i+1],a=m.data[i+2];t.update(e,r,n)}return t}var z=m=>({epochs:100,batchSize:m>10?10:m,async:!1}),Y=class{constructor(t,e={}){this.shape=t;this.mode="sgd";this.rate=.01;if(this.hlayer=t.length-1,this.hlayer<1)throw new Error("The network has at least two layers");this.w=[],this.b=[];for(let r=0;r<this.hlayer;r++)this.w[r]=u.generate(this.unit(r),this.unit(r-1)),this.b[r]=u.generate(1,this.unit(r));e.mode&&(this.mode=e.mode),e.rate&&(this.rate=e.rate),e.w&&(this.w=e.w),e.b&&(this.b=e.b),e.scale&&(this.scale=e.scale)}unit(t){let e=this.shape[t+1];return Array.isArray(e)?e[0]:e}af(t){let e=this.shape[t+1];return Array.isArray(e)?e[1]:void 0}toJSON(){return JSON.stringify({mode:this.mode,shape:this.shape,rate:this.rate,scale:this.scale?this.scale.dataSync():void 0,w:this.w.map(t=>t.dataSync()),b:this.b.map(t=>t.dataSync())})}static fromJSON(t){let e=JSON.parse(t),r=e.w.map(s=>new u(s)),i=e.b.map(s=>new u(s)),n=e.scale?new u(e.scale):void 0;return new Y(e.shape,{mode:e.mode,rate:e.mode,w:r,b:i,scale:n})}forwardPropagation(t){let e=[];for(let r=0;r<this.hlayer;r++){let i=r===0?t:e[r-1],n=this.af(r),s=i.multiply(this.w[r].T).atomicOperation((a,o,h)=>a+this.b[r].get(0,h));e[r]=s.atomicOperation((a,o)=>O(a,s.getRow(o),n))}return e}scaled(t){return this.scale?t.atomicOperation((e,r,i)=>{let n=this.scale,s=n.get(1,i),a=n.get(0,i);return s===0?0:(e-a)/s}):t}predict(t){let e=this.predictNet(t);return e[e.length-1]}predictNet(t){this.checkInput(t),t=this.scaled(t);let e=this.forwardPropagation(t);return[t,...e]}backPropagation(t,e,r){let i=r.shape[0];if(i===1)return this.calcBackPropagation(t,e,r);let n=this.w.map(h=>h.zeroed()),s=this.b.map(h=>h.zeroed());for(let h=0;h<i;h++){let l=t.map(f=>new u([f.getRow(h)])),c=new u([e.getRow(h)]),p=new u([r.getRow(h)]),{dw:d,dy:g}=this.calcBackPropagation(l,c,p);n=n.map((f,w)=>f.addition(d[w])),s=s.map((f,w)=>f.addition(g[w]))}let a=n.map(h=>h.atomicOperation(l=>l/i));return{dy:s.map(h=>h.atomicOperation(l=>l/i)),dw:a}}calcBackPropagation(t,e,r){let i=[],n=[];for(let s=this.hlayer-1;s>=0;s--){let a=t[s-1]?t[s-1]:e,o=this.af(s);s===this.hlayer-1?n[s]=t[s].atomicOperation((h,l,c)=>(h-r.get(l,c))*y(h,o)):n[s]=n[s+1].multiply(this.w[s+1]).atomicOperation((h,l,c)=>h*y(t[s].get(l,c),o)),i[s]=n[s].T.multiply(a)}return{dy:n,dw:i}}adjust(t,e){this.w=this.w.map((r,i)=>r.subtraction(e[i].multiply(this.rate))),this.b=this.b.map((r,i)=>r.subtraction(t[i].multiply(this.rate)))}cost(t,e){let r=e.shape[0],n=t.subtraction(e).atomicOperation(s=>s**2/2).columnSum().getRow(0).map(s=>s/r);return n.reduce((s,a)=>s+a)/n.length}calcLoss(t,e){this.checkSample(t,e);let r=this.predict(t);return this.cost(r,e)}async bgd(t,e,r){for(let i=0;i<r.epochs;i++){let n=this.forwardPropagation(t),{dy:s,dw:a}=this.backPropagation(n,t,e);this.adjust(s,a),r.onEpoch&&(r.onEpoch(i,this.cost(n[n.length-1],e)),r.async&&await new Promise(o=>setTimeout(o))),r.onTrainEnd&&i===r.epochs-1&&r.onTrainEnd(this.cost(n[n.length-1],e))}}async sgd(t,e,r){let i=e.shape[0];for(let n=0;n<r.epochs;n++){let s=null;for(let a=0;a<i;a++){let o=new u([t.getRow(a)]),h=new u([e.getRow(a)]),l=this.forwardPropagation(o),{dy:c,dw:p}=this.backPropagation(l,o,h);this.adjust(c,p),s=s?s.connect(l[l.length-1]):l[l.length-1]}r.onEpoch&&(r.onEpoch(n,this.cost(s,e)),r.async&&await new Promise(a=>setTimeout(a))),r.onTrainEnd&&n===r.epochs-1&&r.onTrainEnd(this.cost(s,e))}}async mbgd(t,e,r){let i=e.shape[0],n=r.batchSize,s=Math.ceil(i/n);for(let a=0;a<r.epochs;a++){let{xs:o,ys:h}=R(t,e),l=0;for(let c=0;c<s;c++){let p=c*n,d=p+n;d=d>i?i:d;let g=d-p,f=o.slice(p,d),w=h.slice(p,d),M=this.forwardPropagation(f),b=M[M.length-1],{dy:S,dw:X}=this.backPropagation(M,f,w);this.adjust(S,X);let T=this.cost(b,w);l+=T,r.onBatch&&r.onBatch(c,g,T)}r.onEpoch&&(r.onEpoch(a,l/s),r.async&&await new Promise(c=>setTimeout(c))),r.onTrainEnd&&a===r.epochs-1&&r.onTrainEnd(l/s)}}checkInput(t){if(t.shape[1]!==this.unit(-1))throw new Error(`Input matrix column number error, input shape -> ${this.unit(-1)}.`)}checkOutput(t){if(t.shape[1]!==this.unit(this.hlayer-1))throw new Error(`Output matrix column number error, output shape -> ${this.unit(this.hlayer-1)}.`)}checkSample(t,e){if(t.shape[0]!==e.shape[0])throw new Error("The row number of input and output matrix is not uniform.");this.checkInput(t),this.checkOutput(e)}fit(t,e,r={}){let i=e.shape[0],n={...z(i),...r};if(this.checkSample(t,e),n.batchSize>i)throw new Error("The batch size cannot be greater than the number of samples.");let[s,a]=t.normalization();switch(this.scale=a,t=s,this.mode){case"bgd":return this.bgd(t,e,n);case"mbgd":return this.mbgd(t,e,n);case"sgd":default:return this.sgd(t,e,n)}}};var k=class{constructor(t){this.indexWord={};this.wordIndex={};this.hidenSize=10;this.finis="/n";this.rate=.01;this.trainData=t.trainData,t.rate&&(this.rate=t.rate);let e=Array.from(new Set(this.trainData.map(r=>r.split("")).flat(1)));for(let r=0;r<e.length;r++)this.indexWord[e[r]]=r,this.wordIndex[r]=e[r];this.inputSize=e.length,this.outputSize=this.inputSize+1,this.wordIndex[e.length]=this.finis,this.indexWord[this.finis]=e.length,this.U=u.generate(this.hidenSize,this.inputSize),this.W=u.generate(this.hidenSize,this.hidenSize),this.V=u.generate(this.outputSize,this.hidenSize),this.firstSt=u.generate(1,this.hidenSize,0)}oneHotXs(t){let e=u.generate(1,this.inputSize,0);return e.update(0,t,1),e}oneHotYs(t){let e=u.generate(1,this.outputSize,0);return e.update(0,t,1),e}generateXs(t){return t.split("").map(r=>{let i=this.indexWord[r];if(isNaN(i))throw new Error(`checked word non-existent from dictionary is ${r}`);return this.oneHotXs(i)})}generateYs(t){let e=t.split("");return e.map((r,i)=>{let n=e[i+1]?e[i+1]:this.finis,s=this.indexWord[n];return this.oneHotYs(s)})}forwardPropagation(t){let e=[];for(let r=0;r<t.length;r++){let i=t[r],n=r===0?this.firstSt:e[r-1].st,{st:s,yt:a}=this.calcForward(i,n);e.push({st:s,yt:a})}return e}calcForward(t,e){let r=t.multiply(this.U.T).addition(e.multiply(this.W.T));r=r.atomicOperation((n,s)=>O(n,r.getRow(s),"Tanh"));let i=r.multiply(this.V.T);return i=i.atomicOperation((n,s)=>O(n,i.getRow(s),"Softmax")),{st:r,yt:i}}backPropagation(t,e,r){let i=this.V.zeroed(),n=this.U.zeroed(),s=this.W.zeroed();for(let a=0;a<t.length;a++){let{st:o,yt:h}=t[a],l=e[a],c=r[a],p=a===0?this.firstSt:t[a-1].st,d=h.atomicOperation((b,S,X)=>(b-c.get(S,X))*y(b,"Softmax")),g=d.multiply(this.V);g=g.atomicOperation((b,S,X)=>b*y(o.get(S,X),"Tanh"));let f=d.T.multiply(o),w=g.T.multiply(l),M=g.T.multiply(p);i=i.addition(f),n=n.addition(w),s=s.addition(M)}this.U=this.U.subtraction(n.multiply(this.rate)),this.W=this.W.subtraction(s.multiply(this.rate)),this.V=this.V.subtraction(i.multiply(this.rate))}predict(t,e=10){let r=this.generateXs(t),i=this.forwardPropagation(r),n=i[i.length-1],s=n.yt.argMax(0),a=n.st,o="";if(o+=this.wordIndex[s],s===this.inputSize)return o;for(let h=0;h<e-1;h++){let l=this.oneHotXs(s),c=this.calcForward(l,a);if(s=c.yt.argMax(0),a=c.st,o+=this.wordIndex[s],s===this.inputSize)break}return o}cost(t,e){return t.map((i,n)=>{let{yt:s}=i,a=e[n],o=s.subtraction(a).atomicOperation(h=>h**2/2).getRow(0);return o.reduce((h,l)=>h+l)/o.length}).reduce((i,n)=>i+n)}fit(t={}){let{epochs:e=1e3,onEpochs:r}=t;for(let i=0;i<e;i++){let n=0;for(let s=0;s<this.trainData.length;s++){let a=this.trainData[s],o=this.generateXs(a),h=this.generateYs(a),l=this.forwardPropagation(o);this.backPropagation(l,o,h),n+=this.cost(l,h)}r&&r(i,n/this.trainData.length)}}};export{Y as BPNet,E as Edge,u as Matrix,x as Point,P as Polygon,k as RNN,y as afd,O as afn,A as canvasToMatrix,z as defaultTrainingOptions,F as toFixed,R as upset};
